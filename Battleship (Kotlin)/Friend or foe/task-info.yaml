type: edu
files:
  - name: src/battleship/Main.kt
    visible: true
    text: |-
      package battleship
      
      fun main() {
          println("Hello World!")
      }
    learner_created: false
  - name: test/Tests.java
    visible: false
    text: |-
      import org.hyperskill.hstest.dynamic.input.DynamicTestingMethod;
      import org.hyperskill.hstest.exception.outcomes.WrongAnswer;
      import org.hyperskill.hstest.stage.StageTest;
      import org.hyperskill.hstest.testcase.CheckResult;
      import org.hyperskill.hstest.testing.TestedProgram;
      
      
      public class Tests extends StageTest<String> {
          @DynamicTestingMethod
          CheckResult testExample() {
      
              TestedProgram main = new TestedProgram();
              String output = main.start().trim();
              String[][] matrix;
      
              if (!matrixIsEmpty(getFieldMatrix(output))) {
                  return CheckResult.wrong("Not an empty game field at the start of the game");
              }
      
              // Filling the first player field
              if (!output.toLowerCase().contains("aircraft carrier")) {
                  return CheckResult.wrong("After starting the program, you should request " +
                      "the coordinates of the Aircraft Carrier in that way:\n" +
                      "\"Enter the coordinates of the Aircraft Carrier (5 cells):\"");
              }
      
              output = main.execute("F3 F7").trim();
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "F3 F7");
      
              if (!output.toLowerCase().contains("battleship")) {
                  return CheckResult.wrong("After asking for the Aircraft Carrier coordinates, you should request " +
                      "the coordinates of the Battleship in that way:\n" +
                      "\"Enter the coordinates of the Battleship (4 cells):\"");
              }
      
              output = main.execute("A1 D1").trim();
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "A1 D1");
      
              if (!output.toLowerCase().contains("submarine")) {
                  return CheckResult.wrong("After asking for the Battleship coordinates, you should request " +
                      "the coordinates of the Submarine in that way:\n" +
                      "\"Enter the coordinates of the Submarine (3 cells):\"");
              }
      
              output = main.execute("J7 J10").trim();
              if (isGameFieldPrinted(output)) {
                  return CheckResult.wrong("Your program should not print a game field if there is an input mistake.");
              }
      
              output = main.execute("J10 J8").trim();
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "J10 J8");
      
              if (!output.toLowerCase().contains("cruiser")) {
                  return CheckResult.wrong("After asking for the Submarine coordinates, you should request " +
                      "the coordinates of the Cruiser in that way:\n" +
                      "\"Enter the coordinates of the Cruiser (3 cells):\"");
              }
      
              output = main.execute("B9 D8").trim();
              if (isGameFieldPrinted(output)) {
                  return CheckResult.wrong("Your program should not print a game field if there is an input mistake.");
              }
      
              output = main.execute("B9 D9").trim();
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "B9 D9");
      
              if (!output.toLowerCase().contains("destroyer")) {
                  return CheckResult.wrong("After asking for the Cruiser coordinates, you should request " +
                      "the coordinates of the Destroyer in that way:\n" +
                      "\"Enter the coordinates of the Destroyer (2 cells):\"");
              }
      
              output = main.execute("E6 D6").trim();
              if (isGameFieldPrinted(output)) {
                  return CheckResult.wrong("Your program should not print a game field if there is an input mistake. " +
                      "(Too close to another ship)");
              }
      
              output = main.execute("I2 J2").trim();
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "I2 J2");
      
              if (!output.toLowerCase().contains("enter")) {
                  return CheckResult.wrong("No offer found to give the move to another player");
              }
      
              output = main.execute("");
      
              // Filling the second player field
      
              if (!output.toLowerCase().contains("aircraft carrier")) {
                  return CheckResult.wrong("After filling the first player field, you should request the second player's " +
                      "coordinates of the Aircraft Carrier in that way:\n" +
                      "\"Enter the coordinates of the Aircraft Carrier (5 cells):\"");
              }
      
              output = main.execute("H2 H6");
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "H2 H6");
      
              if (!output.toLowerCase().contains("battleship")) {
                  return CheckResult.wrong("After asking for the Aircraft Carrier coordinates, you should request " +
                      "the coordinates of the Battleship in that way:\n" +
                      "\"Enter the coordinates of the Battleship (4 cells):\"");
              }
      
              output = main.execute("F3 F6");
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "F3 F6");
      
              if (!output.toLowerCase().contains("submarine")) {
                  return CheckResult.wrong("After asking for the Battleship coordinates, you should request " +
                      "the coordinates of the Submarine in that way:\n" +
                      "\"Enter the coordinates of the Submarine (3 cells):\"");
              }
      
              output = main.execute("H8 F8").trim();
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "H8 F8");
      
              if (!output.toLowerCase().contains("cruiser")) {
                  return CheckResult.wrong("After asking for the Submarine coordinates, you should request " +
                      "the coordinates of the Cruiser in that way:\n" +
                      "\"Enter the coordinates of the Cruiser (3 cells):\"");
              }
      
              output = main.execute("D4 D6").trim();
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "D4 D6");
      
              if (!output.toLowerCase().contains("destroyer")) {
                  return CheckResult.wrong("After asking for the Cruiser coordinates, you should request " +
                      "the coordinates of the Destroyer in that way:\n" +
                      "\"Enter the coordinates of the Destroyer (2 cells):\"");
              }
      
              output = main.execute("D8 C8");
              matrix = getFieldMatrix(output);
              findShipByCoordinates(matrix, "D8 C8");
      
              if (!output.toLowerCase().contains("enter")) {
                  return CheckResult.wrong("no offer found to give the move to another player");
              }
              output = main.execute("");
      
              // Players' moves
              String[] splittedOutput = output.split("---\n");
              if (splittedOutput.length != 2) {
                  return CheckResult.wrong("An incorrect number of game fields.\nThere is should 2 fields separated by \"---------------------\"");
              }
              if (!matrixIsEmpty(getFieldMatrix(splittedOutput[0]))) {
                  return CheckResult.wrong("At the start of the game the upper field should be empty");
              }
              findAllShips(getFieldMatrix(splittedOutput[1]),
                  new String[]{"F3 F7", "A1 D1", "J10 J8", "B9 D9", "I2 J2"});
      
              output = main.execute("I3");
              if (!output.toLowerCase().contains("missed")) {
                  return CheckResult.wrong("Incorrect reaction of the program if the player missed");
              }
      
              output = main.execute("");
              checkMissing(getFieldMatrix(output), "I3");
      
              splittedOutput = output.split("---\n");
              if (splittedOutput.length != 2) {
                  return CheckResult.wrong("An incorrect number of game fields (2 should be)");
              }
              if (!matrixIsEmpty(getFieldMatrix(splittedOutput[0]))) {
                  return CheckResult.wrong("At the start of the game the upper field should be empty");
              }
              findAllShips(getFieldMatrix(splittedOutput[1]),
                  new String[]{"H2 H6", "F3 F6", "H8 F8", "D4 D6", "D8 C8"});
      
              output = main.execute("C9");
              if (!output.toLowerCase().contains("hit")) {
                  return CheckResult.wrong("Incorrect reaction of the program if the player hit the ship");
              }
              main.execute("");
      
              makeMoveTillTheEnd(main);
      
              return CheckResult.correct();
          }
      
          void makeMoveTillTheEnd(TestedProgram main) {
      
              String[] secondPlayerMoves = {"A1", "B1", "C1", "D1", "B9", "C9", "D9", "F3", "F4", "F5", "F6", "F7", "I2", "J2", "J8", "J9", "J10"};
              String[] firstPlayerMoves = {"D4", "D5", "D6", "C8", "D8", "F3", "F4", "F5", "F6", "F7", "D10", "E10", "F10", "G10", "J1", "J2", "J3"};
      
              String[][] matrix;
              String output;
              int i;
      
              for (i = 0; i < 3; i++) {
                  main.execute(firstPlayerMoves[i]);
                  main.execute("");
                  main.execute(secondPlayerMoves[i]);
                  main.execute("");
              }
      
              main.execute(firstPlayerMoves[i]);
              main.execute("");
      
              output = main.execute(secondPlayerMoves[i]);
              if (!output.contains("sank")) {
                  throw new WrongAnswer("After a ship was sunk you should print \"You sank a ship!\" and ask to press Enter.");
              }
              output = main.execute("");
      
              String[] splittedOutput = output.split("---\n");
              if (splittedOutput.length != 2) {
                  throw new WrongAnswer("An incorrect number of game fields.\nThere is should 2 fields separated by \"---------------------\"");
              }
      
              matrix = getFieldMatrix(splittedOutput[1]);
              checkShot(matrix, "A1");
              checkShot(matrix, "B1");
              checkShot(matrix, "C1");
              checkShot(matrix, "D1");
      
              for (i = i + 1; i < secondPlayerMoves.length - 1; i++) {
                  main.execute(firstPlayerMoves[i]);
                  main.execute("");
                  main.execute(secondPlayerMoves[i]);
                  main.execute("");
              }
      
              main.execute(firstPlayerMoves[i]);
              main.execute("");
              output = main.execute(secondPlayerMoves[i]).toLowerCase();
      
              if (!output.contains("won") || !output.contains("congratulations")) {
                  throw new WrongAnswer("If a player has sunk all enemy ships you should print:\n" +
                      "\"You sank the last ship. You won. Congratulations!\"");
              }
          }
      
          void findShipByCoordinates(String[][] matrix, String coordinates) {
              int[] coordinatesInt = parseCoordinates(coordinates);
      
              if (coordinatesInt[0] > coordinatesInt[2]) {
                  int swap = coordinatesInt[0];
                  coordinatesInt[0] = coordinatesInt[2];
                  coordinatesInt[2] = swap;
              } else if (coordinatesInt[1] > coordinatesInt[3]) {
                  int swap = coordinatesInt[1];
                  coordinatesInt[1] = coordinatesInt[3];
                  coordinatesInt[3] = swap;
              }
      
              if (coordinatesInt[0] == coordinatesInt[2]) {
                  int cord = coordinatesInt[0];
                  for (int i = coordinatesInt[1]; i <= coordinatesInt[3]; i++) {
                      if (!matrix[cord][i].toLowerCase().equals("x") && !matrix[cord][i].toLowerCase().equals("o")) {
                          throw new WrongAnswer("The ship's cells were not found at the coordinates \"" + coordinates + "\"");
                      }
                  }
              } else {
                  int cord = coordinatesInt[1];
                  for (int i = coordinatesInt[0]; i <= coordinatesInt[2]; i++) {
                      if (!matrix[i][cord].toLowerCase().equals("x") && !matrix[i][cord].toLowerCase().equals("o")) {
                          throw new WrongAnswer("The ship's cells were not found at the \"" + coordinates + "\"");
                      }
                  }
              }
          }
      
          boolean matrixIsEmpty(String[][] matrix) {
              for (String[] strings : matrix) {
                  for (int j = 0; j < matrix.length; j++) {
                      if (!strings[j].trim().equals("~")) {
                          return false;
                      }
                  }
              }
              return true;
          }
      
          void checkShot(String[][] matrix, String coordinate) {
              int[] parsedCoordinate = new int[2];
              parsedCoordinate[0] = charToInt(coordinate.toLowerCase().substring(0, 1));
              parsedCoordinate[1] = Integer.parseInt(coordinate.substring(1)) - 1;
      
              if (!matrix[parsedCoordinate[0]][parsedCoordinate[1]].toLowerCase().contains("x")) {
                  throw new WrongAnswer("Expected hit in \"" + coordinate + "\".");
              }
          }
      
          boolean checkMissing(String[][] matrix, String coordinate) {
              int[] parsedCoordinate = new int[2];
              parsedCoordinate[0] = charToInt(coordinate.toLowerCase().substring(0, 1));
              parsedCoordinate[1] = Integer.parseInt(coordinate.substring(1)) - 1;
      
              return matrix[parsedCoordinate[0]][parsedCoordinate[1]].toLowerCase().contains("m");
          }
      
          int[] parseCoordinates(String coordinatesString) {
              String[] splittedCoords = coordinatesString.split(" ");
              int[] parsedCoordinates = new int[4];
      
              parsedCoordinates[0] = charToInt(splittedCoords[0].substring(0, 1));
              parsedCoordinates[1] = Integer.parseInt(splittedCoords[0].substring(1)) - 1;
              parsedCoordinates[2] = charToInt(splittedCoords[1].substring(0, 1));
              parsedCoordinates[3] = Integer.parseInt(splittedCoords[1].substring(1)) - 1;
      
              return parsedCoordinates;
          }
      
          int charToInt(String charCoordinate) {
              charCoordinate = charCoordinate.toLowerCase();
              char character = charCoordinate.charAt(0);
              return (int) character - (int) 'a';
          }
      
          String[][] getFieldMatrix(String output) {
      
              WrongAnswer cantParseException = new WrongAnswer("Can't parse the game field\n" +
                  "Make sure you print it like in examples!");
      
              String[] splittedOutput = output.split("\n");
              String[][] matrix = new String[10][10];
      
              try {
                  int index = 0;
                  while (!(splittedOutput[index].contains("1") &&
                      splittedOutput[index].contains("2") &&
                      splittedOutput[index].contains("10"))) {
                      index++;
                      if (index > 1000) {
                          throw cantParseException;
                      }
                  }
                  index++;
      
                  for (int i = 0; i < 10; i++) {
                      String temp = splittedOutput[index].substring(2).trim();
                      String[] splittedLine = temp.trim().split(" ");
                      if (splittedLine.length != 10) {
                          throw cantParseException;
                      }
                      matrix[i] = splittedLine;
                      index++;
                  }
              } catch (IndexOutOfBoundsException ignored) {
                  throw cantParseException;
              }
      
              return matrix;
          }
      
          boolean isGameFieldPrinted(String output) {
              return output.contains("1") && output.contains("2") && output.contains("10");
          }
      
          void findAllShips(String[][] matrix, String[] coordinates) {
              for (String item : coordinates) {
                  findShipByCoordinates(matrix, item);
              }
          }
      }
    learner_created: false
  - name: src/battleship/game_field/GameField.kt
    visible: true
    text: |
      package battleship.game_field
      
      import battleship.ship.Ship
      import battleship.ship.Type as ShipType
      
      enum class CellStatus(val label: Char) {
          FOG('~'),
          SHIP('O'),
          HIT('X'),
          MISS('M'),
      }
      
      class GameField {
      
          private val rowLabels = ('A'..'J').toList()
      
          private val ships = emptyMap<ShipType, Ship>().toMutableMap()
      
          private val cols = (1..10).map { it.toString() }
          private val rows = (1..10).map { (1..10).map { CellStatus.FOG }.toMutableList() }.toMutableList()
      
          fun getShipTypesToAdd(): List<ShipType> = ShipType.values().filter { !ships.contains(it) }
          fun addShip(ship: Ship) {
      
              if (ships.containsKey(ship.type)) throw RuntimeException("Error! Already added ${ship.type.label}")
              if (ship.location.size != ship.type.size) throw RuntimeException("Error! Wrong length of the ${ship.type.label}!")
              if (isTooCloseToAnotherShip(ship)) throw RuntimeException("Error! You placed it too close to another one.")
      
              ships[ship.type] = ship
              when (ship.location.isHorizontal) {
                  true -> {
                      val rowLabel: Char = ship.location.startRow
                      val row = getRowFromLabel(rowLabel)
                      if (!(1..10).contains(row)) throw RuntimeException()
      
                      (ship.location.startCol..ship.location.endCol)
                          .forEach { col -> plotCellValue(Coordinate("${getLabelFromRow(row)}$col"), CellStatus.SHIP) }
                  }
      
                  false -> {
                      val col: Int = ship.location.startCol
      
                      (ship.location.startRow..ship.location.endRow)
                          .forEach { row -> plotCellValue(Coordinate("$row$col"), CellStatus.SHIP) }
                  }
              }
          }
      
          fun isReady(): Boolean = ShipType.values().size == ships.size
          fun hasEnded(): Boolean = ships.values.filter { it.isSunk }.size == ships.size
      
          fun takeAShot(coordinate: Coordinate): Ship? {
      
              val ship = ships.values.firstOrNull { it.occupiesCell(coordinate) }
              ship?.takeShot(coordinate)
      
              val cellValue = if (ship?.isHit == true) CellStatus.HIT else CellStatus.MISS
              plotCellValue(coordinate, cellValue)
      
              return ship
          }
      
          fun getCellValue(coordinate: Coordinate) = rows[getRowFromLabel(coordinate.row) - 1][coordinate.col - 1]
      
          fun toStringWithFogOfWar(): String = this.toString().replace(CellStatus.SHIP.label, CellStatus.FOG.label)
      
          override fun toString(): String {
              return """
      ${getRowString(row = cols)}
      ${rowLabels.mapIndexed { k, label -> "$label ${rows[k].map { it.label }.joinToString(" ")}" }.joinToString("\n")}
              """
          }
      
          private fun plotCellValue(coordinate: Coordinate, cellValue: CellStatus) {
              rows[getRowFromLabel(coordinate.row) - 1][coordinate.col - 1] = cellValue
          }
      
          private fun getRowFromLabel(rowLabel: Char) = rowLabels.indexOf(rowLabel) + 1
      
          private fun getLabelFromRow(row: Int) = rowLabels.toList()[row - 1]
      
          private fun isTooCloseToAnotherShip(ship: Ship): Boolean {
              val startCol = 1.coerceAtLeast(ship.location.startCol - 1)
              val endCol = cols.size.coerceAtMost(ship.location.endCol + 1)
      
              val startRow = 1.coerceAtLeast(rowLabels.indexOf(ship.location.startRow))
              val endRow = rows.size.coerceAtMost(rowLabels.indexOf(ship.location.endRow) + 2)
      
              (startCol..endCol).forEach { col ->
                  (startRow..endRow).forEach { row ->
                      if (getCellValue(Coordinate("${getLabelFromRow(row)}$col")) == CellStatus.SHIP) return true
                  }
              }
      
              return false
          }
      
          private fun getRowString(key: Char = ' ', row: List<String>) = "$key ${row.joinToString(" ").trim()}"
      }
    learner_created: true
  - name: test/battleship/game_field/GameFieldTest.kt
    visible: true
    text: |-
      package battleship.game_field
      
      import battleship.ship.Ship
      import battleship.ship.Location
      import battleship.ship.Type
      import org.junit.Assert.*
      import org.junit.Test
      
      class GameFieldTest {
      
          @Test
          fun `it should get a list of all ShipType`() {
              val gameField = GameField()
              assertEquals(
                  "[AIRCRAFT_CARRIER, BATTLESHIP, SUBMARINE, CRUISER, DESTROYER]", gameField.getShipTypesToAdd().toString()
              )
          }
      
          @Test
          fun `it should remove ShipType from list when added to GameField`() {
      
              val gameField = GameField()
      
              gameField.addShip(
                  Ship(
                      Type.CRUISER,
                      Location(Coordinate("A1"), Coordinate("A3"))
                  )
              )
      
              assertEquals(
                  "[AIRCRAFT_CARRIER, BATTLESHIP, SUBMARINE, DESTROYER]",
                  gameField.getShipTypesToAdd().toString()
              )
          }
      
          @Test
          fun `it should add a ship to the GameField`() {
              val gameField = GameField()
      
              gameField.addShip(
                  Ship(
                      Type.AIRCRAFT_CARRIER,
                      Location(Coordinate("B4"), Coordinate("F4"))
                  )
              )
      
              assertEquals(
                  """
        1 2 3 4 5 6 7 8 9 10
      A ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      B ~ ~ ~ O ~ ~ ~ ~ ~ ~
      C ~ ~ ~ O ~ ~ ~ ~ ~ ~
      D ~ ~ ~ O ~ ~ ~ ~ ~ ~
      E ~ ~ ~ O ~ ~ ~ ~ ~ ~
      F ~ ~ ~ O ~ ~ ~ ~ ~ ~
      G ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      H ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      I ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      J ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
              """,
                  gameField.toString()
              )
          }
      
          @Test
          fun `it should not add the same ShipType twice`() {
              val shipType = Type.DESTROYER
              val exception = assertThrows(RuntimeException::class.java) {
                  val gameField = GameField()
      
                  gameField.addShip(Ship(shipType, Location(Coordinate("A1"), Coordinate("B1"))))
                  gameField.addShip(Ship(shipType, Location(Coordinate("I10"), Coordinate("J10"))))
              }
      
              assertEquals("Error! Already added ${shipType.label}", exception.message)
          }
      
          @Test
          fun `it should return true when all ShipType are added to GameField`() {
      
              val gameField = GameField()
      
              assertFalse(gameField.isReady())
      
              listOf(
                  Ship(Type.AIRCRAFT_CARRIER, Location(Coordinate("F3"), Coordinate("F7"))),
                  Ship(Type.BATTLESHIP, Location(Coordinate("A1"), Coordinate("D1"))),
                  Ship(Type.SUBMARINE, Location(Coordinate("J10"), Coordinate("J8"))),
                  Ship(Type.CRUISER, Location(Coordinate("B9"), Coordinate("D9"))),
                  Ship(Type.DESTROYER, Location(Coordinate("I2"), Coordinate("J2"))),
              ).forEach { gameField.addShip(it) }
      
              assertTrue(gameField.isReady())
          }
      
          @Test
          fun `it should take a shot and hit`() {
      
              val gameField = GameField()
      
              val coordinate = Coordinate("F3")
              listOf(
                  Ship(Type.AIRCRAFT_CARRIER, Location(Coordinate("F3"), Coordinate("F7"))),
                  Ship(Type.BATTLESHIP, Location(Coordinate("A1"), Coordinate("D1"))),
                  Ship(Type.SUBMARINE, Location(Coordinate("J10"), Coordinate("J8"))),
                  Ship(Type.CRUISER, Location(Coordinate("B9"), Coordinate("D9"))),
                  Ship(Type.DESTROYER, Location(Coordinate("I2"), Coordinate("J2"))),
              ).forEach { gameField.addShip(it) }
      
              assertEquals(CellStatus.SHIP, gameField.getCellValue(coordinate))
      
              assertNotNull(gameField.takeAShot(coordinate))
              assertEquals(CellStatus.HIT, gameField.getCellValue(coordinate))
      
              assertNotNull(gameField.takeAShot(coordinate))
              assertEquals(CellStatus.HIT, gameField.getCellValue(coordinate))
          }
      
          @Test
          fun `it should take a shot and miss`() {
              val gameField = GameField()
      
              val coordinate = Coordinate("F2")
              listOf(
                  Ship(Type.AIRCRAFT_CARRIER, Location(Coordinate("F3"), Coordinate("F7"))),
                  Ship(Type.BATTLESHIP, Location(Coordinate("A1"), Coordinate("D1"))),
                  Ship(Type.SUBMARINE, Location(Coordinate("J10"), Coordinate("J8"))),
                  Ship(Type.CRUISER, Location(Coordinate("B9"), Coordinate("D9"))),
                  Ship(Type.DESTROYER, Location(Coordinate("I2"), Coordinate("J2"))),
              ).forEach { gameField.addShip(it) }
      
              assertEquals(CellStatus.FOG, gameField.getCellValue(coordinate))
      
              assertNull(gameField.takeAShot(coordinate))
              assertEquals(CellStatus.MISS, gameField.getCellValue(coordinate))
      
              assertNull(gameField.takeAShot(coordinate))
              assertEquals(CellStatus.MISS, gameField.getCellValue(coordinate))
          }
      
          @Test
          fun `it should return game field as string`() {
              assertEquals(
                  """
        1 2 3 4 5 6 7 8 9 10
      A ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      B ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      C ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      D ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      E ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      F ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      G ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      H ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      I ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
      J ~ ~ ~ ~ ~ ~ ~ ~ ~ ~
              """,
                  GameField().toString()
              )
          }
      }
    learner_created: true
  - name: test/battleship/game_field/CoordinateTest.kt
    visible: true
    text: |-
      package battleship.game_field
      
      import org.junit.Assert.assertEquals
      import org.junit.Assert.assertThrows
      import org.junit.Test
      
      class CoordinateTest {
      
          @Test
          fun `it should throw on invalid coordinate`() {
              listOf(
                  "A0",
                  "1A",
                  "A11",
                  "K5",
                  "",
                  " ",
                  "foobar"
                  ).forEach {
                  val exception = assertThrows(RuntimeException::class.java) {
                      println(it)
                      Coordinate(it)
                  }
      
                  println(exception)
      
                  assertEquals("Error! You entered the wrong coordinates!", exception.message)
              }
          }
      
          @Test
          fun `it should be generous in what it accepts`() {
              listOf(
                  "A1",
                  "a1",
                  "A 1",
                  "a 1",
                  " A 1 ",
                  " a 1 ",
              ).forEach {
                  val coordinate = Coordinate(it)
                  assertEquals('A', coordinate.row)
                  assertEquals(1, coordinate.col)
              }
          }
      
          @Test
          fun `it should get the Coordinate row`() {
              assertEquals(
                  'F',
                  Coordinate("F4").row
              )
          }
      
          @Test
          fun `it should get the Coordinate col`() {
              assertEquals(
                  4,
                  Coordinate("F4").col
              )
          }
      }
    learner_created: true
  - name: src/battleship/ship/Cell.kt
    visible: true
    text: |-
      package battleship.ship
      
      import battleship.game_field.Coordinate
      
      class Cell(val coordinate: Coordinate, private var _isHit: Boolean = false) {
      
          val isHit: Boolean get() = _isHit
      
          fun hit(): Unit {
              _isHit = true
          }
      }
    learner_created: true
  - name: test/battleship/ship/LocationTest.kt
    visible: true
    text: |-
      package battleship.ship
      
      import battleship.game_field.Coordinate
      import org.junit.Assert.*
      import org.junit.Test
      
      class LocationTest {
      
          @Test
          fun `it should return start row of ShipLocation`() {
              listOf(
                  listOf("C1", "D1", 'C'),
                  listOf("D1", "C1", 'C'),
                  listOf("D1", "D2", 'D'),
                  listOf("D2", "D1", 'D')
              ).forEach { args ->
                  assertEquals(
                      args[2],
                      Location(Coordinate(args[0].toString()), Coordinate(args[1].toString())).startRow
                  )
              }
          }
      
          @Test
          fun `it should return end row of ShipLocation`() {
              listOf(
                  listOf("C1", "D1", 'D'),
                  listOf("D1", "C1", 'D'),
                  listOf("C1", "C2", 'C'),
                  listOf("C2", "C1", 'C')
              ).forEach { args ->
                  assertEquals(args[2], Location(Coordinate(args[0].toString()), Coordinate(args[1].toString())).endRow)
              }
          }
      
          @Test
          fun `it should return start col of ShipLocation`() {
              listOf(
                  listOf("C1", "C2", 1),
                  listOf("C2", "C1", 1),
                  listOf("C2", "D2", 2),
                  listOf("D2", "C2", 2)
              ).forEach { args ->
                  assertEquals(
                      args[2],
                      Location(Coordinate(args[0].toString()), Coordinate(args[1].toString())).startCol
                  )
              }
          }
      
          @Test
          fun `it should return end col of ShipLocation`() {
              listOf(
                  listOf("C1", "C2", 2),
                  listOf("C2", "C1", 2),
                  listOf("C1", "D1", 1),
                  listOf("D1", "C1", 1)
              ).forEach { args ->
                  assertEquals(args[2], Location(Coordinate(args[0].toString()), Coordinate(args[1].toString())).endCol)
              }
          }
      
          @Test
          fun `it should return true if ShipLocation is horizontal`() {
              listOf(
                  listOf("C1", "C2"),
                  listOf("C2", "C1")
              ).forEach { args ->
                  assertTrue(Location(Coordinate(args[0]), Coordinate(args[1])).isHorizontal)
              }
          }
      
          @Test
          fun `it should return false if ShipLocation is vertical`() {
              listOf(
                  listOf("C1", "D1"),
                  listOf("D1", "C1")
              ).forEach { args ->
                  assertFalse(Location(Coordinate(args[0]), Coordinate(args[1])).isHorizontal)
              }
          }
      
          @Test
          fun `it should return the number of cells the ShipLocation occupies`() {
              listOf(
                  listOf("F3", "F7", 5),
                  listOf("F7", "F3", 5),
                  listOf("A1", "D1", 4),
                  listOf("D1", "A1", 4),
                  listOf("J10", "J8", 3),
                  listOf("I2", "J2", 2),
              ).forEach { args ->
                  assertEquals(args[2], Location(Coordinate(args[0].toString()), Coordinate(args[1].toString())).size)
              }
          }
      }
    learner_created: true
  - name: src/battleship/ship/Ship.kt
    visible: true
    text: |
      package battleship.ship
      
      import battleship.game_field.CellStatus
      import battleship.game_field.Coordinate
      
      class Ship(val type: Type, val location: Location) {
      
          private var cells: List<Cell> = when (location.isHorizontal) {
              true -> (location.startCol..location.endCol).map { col -> Cell(Coordinate("${location.startRow}$col")) }
              false -> (location.startRow..location.endRow).map { row -> Cell(Coordinate("$row${location.startCol}")) }
          }
      
          val isHit: Boolean get() = cells.any { it.isHit }
          val isSunk: Boolean get() = cells.filter { it.isHit }.size == cells.size
      
          fun occupiesCell(coordinate: Coordinate): Boolean = cells.any { it.coordinate.toString() == coordinate.toString() }
          fun takeShot(coordinate: Coordinate): CellStatus {
              val cell: Cell? = cells.find { it.coordinate.toString() == coordinate.toString() }
              cell?.hit()
              return if (cell != null) CellStatus.HIT else CellStatus.MISS
          }
      }
    learner_created: true
  - name: test/battleship/ship/ShipTest.kt
    visible: true
    text: |-
      package battleship.ship
      
      import battleship.game_field.CellStatus
      import battleship.game_field.Coordinate
      import org.junit.Assert.*
      import org.junit.Test
      
      class ShipTest {
      
          @Test
          fun `it should not be hit before a shot fired`() {
              val ship = Ship(Type.AIRCRAFT_CARRIER, Location(Coordinate("A1"), Coordinate("A5")))
      
              assertFalse(ship.isHit)
          }
      
          @Test
          fun `it should be hit`() {
              val ship = Ship(Type.AIRCRAFT_CARRIER, Location(Coordinate("A1"), Coordinate("A5")))
      
              val result = ship.takeShot(Coordinate("A1"))
      
              assertEquals(CellStatus.HIT, result)
              assertTrue(ship.isHit)
          }
      
          @Test
          fun `it should miss`() {
              val ship = Ship(Type.AIRCRAFT_CARRIER, Location(Coordinate("A1"), Coordinate("A5")))
      
              val result = ship.takeShot(Coordinate("B1"))
      
              assertEquals(CellStatus.MISS, result)
              assertFalse(ship.isHit)
          }
      
          @Test
          fun `it should not be sunk`() {
              val ship = Ship(Type.AIRCRAFT_CARRIER, Location(Coordinate("A1"), Coordinate("A5")))
      
              assertFalse(ship.isSunk)
      
              ship.takeShot(Coordinate("A1"))
      
              assertFalse(ship.isSunk)
          }
      
          @Test
          fun `it should be sunk`() {
              val ship = Ship(Type.AIRCRAFT_CARRIER, Location(Coordinate("A1"), Coordinate("A5")))
      
              ship.takeShot(Coordinate("A1"))
              ship.takeShot(Coordinate("A2"))
              ship.takeShot(Coordinate("A3"))
              ship.takeShot(Coordinate("A4"))
              ship.takeShot(Coordinate("A5"))
      
              assertTrue(ship.isSunk)
          }
      
          @Test
          fun `it should occupy a cell`() {
              assertTrue(
                  Ship(
                      Type.AIRCRAFT_CARRIER,
                      Location(Coordinate("A1"), Coordinate("A5"))
                  ).occupiesCell(Coordinate("A1"))
              )
              assertFalse(
                  Ship(
                      Type.AIRCRAFT_CARRIER,
                      Location(Coordinate("A1"), Coordinate("A5"))
                  ).occupiesCell(Coordinate("B1"))
              )
          }
      }
    learner_created: true
  - name: src/battleship/ship/Location.kt
    visible: true
    text: |
      package battleship.ship
      
      import battleship.ERROR_WRONG_SHIP_LOCATION
      import battleship.game_field.Coordinate
      
      class Location(
          private val startCoordinate: Coordinate,
          private val endCoordinate: Coordinate
      ) {
          init {
              if (!isValid()) throw RuntimeException(ERROR_WRONG_SHIP_LOCATION)
          }
      
          val startRow: Char = listOf(startCoordinate.row, endCoordinate.row).minOf { it }
          val endRow: Char = listOf(startCoordinate.row, endCoordinate.row).maxOf { it }
      
          val startCol: Int = listOf(startCoordinate.col, endCoordinate.col).minOf { it }
          val endCol: Int = listOf(startCoordinate.col, endCoordinate.col).maxOf { it }
      
          val isHorizontal = startRow == endRow
      
          val size: Int = when(isHorizontal) {
              true -> {
                  val startEnd = listOf(startCol,endCol).sorted()
                  (startEnd.first()..startEnd.last()).toList().size
              }
              false -> {
                  val startEnd = listOf(startRow,endRow).sorted()
                  (startEnd.first()..startEnd.last()).toList().size
              }
          }
      
          private fun isValid(): Boolean = startCoordinate.row == endCoordinate.row || startCoordinate.col == endCoordinate.col
      }
    learner_created: true
  - name: src/battleship/ship/Type.kt
    visible: true
    text: |-
      package battleship.ship
      
      enum class Type(val label: String, val size: Int) {
          AIRCRAFT_CARRIER("Aircraft Carrier", 5),
          BATTLESHIP("Battleship", 4),
          SUBMARINE("Submarine", 3),
          CRUISER("Cruiser", 3),
          DESTROYER("Destroyer", 2),
      }
    learner_created: true
  - name: src/battleship/game_field/Coordinate.kt
    visible: true
    text: |-
      package battleship.game_field
      
      private const val ERROR_YOU_ENTERED_THE_WRONG_COORDINATES = "Error! You entered the wrong coordinates!"
      
      private const val INVALID_COORDINATE_STRING = "Z99"
      
      class Coordinate(private val _coordinate: String) {
      
          private val coordinate: String get() = _coordinate.trim().uppercase()
      
          val row = coordinate.ifBlank { INVALID_COORDINATE_STRING }.filter { it.isLetter() }.toCharArray().first()
          var col = coordinate.ifBlank { INVALID_COORDINATE_STRING }.filter { it.isDigit() }.ifBlank { "0" }.toInt()
      
          init {
              if (!isValidFormat()) throw RuntimeException(ERROR_YOU_ENTERED_THE_WRONG_COORDINATES)
          }
      
          override fun toString(): String {
              return coordinate
          }
      
          private fun isValidFormat(): Boolean = Regex("^[A-J]\\s*+(?:10|[1-9])$").matches(coordinate)
      }
    learner_created: true
  - name: src/battleship/Game.kt
    visible: true
    learner_created: true
  - name: src/battleship/game_field/CellStatus.kt
    visible: true
    learner_created: true
  - name: src/battleship/Player.kt
    visible: true
    learner_created: true
feedback_link: https://hyperskill.org/learn/step/30259#comment
status: Solved
feedback:
  message: Well done! You've finished the project. Select a new project on <a href="https://hyperskill.org/projects">Hyperskill</a>
    to continue learning.
  time: "Fri, 22 Mar 2024 14:59:59 UTC"
record: -1
